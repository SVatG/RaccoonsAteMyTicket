/**
 * Nordlicht 2022 - Hotel Nordlicht
 * 
 * SVatG 2022 ~ halcy / Saga Musix / dotUser
 **/

#include "Tools.h"
#include "Rocket/sync.h"

#define CLEAR_COLOR 0x555555FF

C3D_Tex fade_tex;
static Pixel* fadePixels;
static Bitmap fadeBitmap;
float fadeVal;

// Autogenerated by music converter
#include "music_meta.h"
u8* music_bin;

// For streaming (WIP/TODO)
// u8* music_bin_play;
// u32 music_bin_play_block;
// 
// u8* music_bin_preload;
// u32 music_bin_preload_block;

#define min(a, b) (((a)<(b))?(a):(b))
#define max(a, b) (((a)>(b))?(a):(b))

#define OGG_IMPL
#define VORBIS_IMPL
#include "minivorbis.h"

#define AUDIO_BLOCKSIZE 16384

#define CHANNELS 2
#define AUDIO_BUFSIZE (512 * CHANNELS)
#define SONG_BPM 127.0
#define SONG_BPS (SONG_BPM / 60.0)
#define SONG_SPS 32000
#define SONG_SPB (SONG_SPS / SONG_BPS) 
#define MUSIC_SIZE ((size_t)(MUSIC_LEN_SEC * CHANNELS * SONG_SPS * sizeof(int16_t)))

#define ROWS_PER_BEAT 8
#define SAMPLES_PER_ROW (SONG_SPB / ROWS_PER_BEAT)

#ifdef SYNC_PLAYER
#define SYNC_OFFSET_SEC 0.35
#else
#define SYNC_OFFSET_SEC 0.0
#endif

int32_t sample_pos = 0;
ndspWaveBuf wave_buffer[2];
uint8_t fill_buffer = 0;
uint8_t audio_playing = 1;

double audio_get_row() {
    double row = (double)(sample_pos + SYNC_OFFSET_SEC * SONG_SPS) / ((double)SAMPLES_PER_ROW);
    return row;
}

// #define DEV_MODE

#ifndef SYNC_PLAYER
void audio_pause(void *ignored, int flag) {
   ignored;
   audio_playing = !flag;
   #ifndef SYNC_PLAYER
        if(audio_playing) {
            float mix[12];
            memset(mix, 0, sizeof(mix));
            mix[0] = 1.0;
            mix[1] = 1.0;    
            ndspChnSetMix(0, mix);
        }
        else {
            float mix[12];
            memset(mix, 0, sizeof(mix));
            mix[0] = 0.0;
            mix[1] = 0.0;    
            ndspChnSetMix(0, mix);
        }
   #endif
}

void audio_set_row(void *ignored, int row) {
    printf("Set row: %d\n", row);
    ignored;
    sample_pos = row * SAMPLES_PER_ROW;
}

int audio_is_playing(void *d) {
    return audio_playing;
}

struct sync_cb rocket_callbakcks = {
    audio_pause,
    audio_set_row,
    audio_is_playing
};
#endif

// Rocket settings
#define ROCKET_HOST CONF_ROCKET_IP
#define SOC_ALIGN 0x1000
#define SOC_BUFFERSIZE 0x100000

static uint32_t *SOC_buffer = NULL;

int connect_rocket() {
#ifndef SYNC_PLAYER
    while(sync_tcp_connect(rocket, ROCKET_HOST, SYNC_DEFAULT_PORT)) {
        printf("Didn't work, again...\n");
        hidScanInput();
        u32 kDown = hidKeysDown();
        if (kDown & KEY_START) {
            return(1);
        }
        svcSleepThread(1000*1000*1000);
    }
#endif
    return(0);
}

FILE *audioFile;
u8 audioTempBuf[AUDIO_BUFSIZE * 4];
void audio_callback(void* ignored) {
    ignored;
    if(wave_buffer[fill_buffer].status == NDSP_WBUF_DONE && (sample_pos + AUDIO_BUFSIZE) * sizeof(int16_t) < MUSIC_SIZE) {
        if(audio_playing == 1) {
            sample_pos += AUDIO_BUFSIZE;
        }
        uint8_t *dest = (uint8_t*)wave_buffer[fill_buffer].data_pcm16;
        
        // For audio streaming (WIP)
//         memcpy(dest, audioTempBuf, AUDIO_BUFSIZE * sizeof(int16_t));
//         wantAudioData = 1;
//         int block_id = (sample_pos - AUDIO_BUFSIZE) / AUDIO_BLOCKSIZE;
//         if(block_id != music_bin_play_block) {
//             printf("Copying audio %d != %d @ %d\n", block_id, music_bin_play_block, sample_pos);
//             memcpy(music_bin_play, music_bin_preload, AUDIO_BLOCKSIZE * sizeof(int16_t));
//             music_bin_play_block = block_id;
//         }
//         int play_pos = (sample_pos - AUDIO_BUFSIZE) % AUDIO_BLOCKSIZE;
        
//         memcpy(dest, &music_bin_play[play_pos * sizeof(int16_t)], AUDIO_BUFSIZE * sizeof(int16_t));
        memcpy(dest, &music_bin[(sample_pos - AUDIO_BUFSIZE) * sizeof(int16_t)], AUDIO_BUFSIZE * sizeof(int16_t));        
        DSP_FlushDataCache(dest, AUDIO_BUFSIZE * sizeof(int16_t));
        ndspChnWaveBufAdd(0, &wave_buffer[fill_buffer]);
        fill_buffer = !fill_buffer;
    }
}

#include <vshader_normalmapping_shbin.h>
#include <vshader_skybox_shbin.h>
#include <vshader_shbin.h>
#include <vshader_bones_shbin.h>

DVLB_s* vshader_dvlb;
DVLB_s* vshader_normalmapping_dvlb;
DVLB_s* vshader_bones_dvlb;
DVLB_s* vshader_skybox_dvlb;
shaderProgram_s shaderProgram;
shaderProgram_s shaderProgramNormalMapping;
shaderProgram_s shaderProgramBones;
shaderProgram_s shaderProgramSkybox;

// For audio streaming (WIP)
// void music_preload(int block_id) {
//     if(block_id != music_bin_preload_block) {
//         int load_pos = block_id * AUDIO_BLOCKSIZE;
// //         printf("Preloading block %d != %d @ %d\n", block_id, music_bin_preload_block, load_pos);
//         fseek(audioFile, load_pos * sizeof(int16_t), SEEK_SET);
//         fread(music_bin_preload, AUDIO_BLOCKSIZE * sizeof(int16_t), 1, audioFile);
//         music_bin_preload_block = block_id;
//     }
// }

// Effect sync structs
typedef void (*init_fun_t)();
typedef void (*render_fun_t)(C3D_RenderTarget* targetLeft, C3D_RenderTarget* targetRight, float iod, float time);
typedef void (*exit_fun_t)();

typedef struct effect { 
    init_fun_t init; 
    render_fun_t render; 
    exit_fun_t exit; 
} effect;

// Externs for effects
extern void effectIntroInit();
extern void effectIntroRender(C3D_RenderTarget* targetLeft, C3D_RenderTarget* targetRight, float row, float iod);
extern void effectIntroExit();

int main() {
    bool DUMPFRAMES = false;
    bool DUMPFRAMES_3D = false;
    float DUMPFRAMES_3D_SEP = 0.4;

    // Set up effect list. Sequencing is done in Rocket
    #define EFFECT_MAX 2
    effect effect_list[EFFECT_MAX];
    
    // The tunnel-actually-platform effect currently will NOT exist cleanly. (TODO FIXME? will be replaced anyways)
    effect_list[0].init = effectIntroInit;
    effect_list[0].render = effectIntroRender;
    effect_list[0].exit = effectIntroExit;
    
    // Actually the effects are just kind of broken generally. TODO: Fix
    effect_list[1].init = effectIntroInit;
    effect_list[1].render = effectIntroRender;
    effect_list[1].exit = effectIntroExit;

    // Initialize graphics
    gfxInit(GSP_RGBA8_OES, GSP_BGR8_OES, false);
    gfxSet3D(true);
    consoleInit(GFX_BOTTOM, NULL);
    C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

    // Initialize the render targets
    C3D_RenderTarget* targetLeft = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTarget* targetRight = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTargetSetOutput(targetLeft, GFX_TOP, GFX_LEFT,  DISPLAY_TRANSFER_FLAGS);
    C3D_RenderTargetSetOutput(targetRight, GFX_TOP, GFX_RIGHT, DISPLAY_TRANSFER_FLAGS);
    
    romfsInit();
    
    // new and lukewarm: predecode an ogg file. saves file size, but precalc sucks.
    // TODO: Convert this to streaming the data in as needed
    FILE* fp = fopen("romfs:/music.ogg", "rb");
    OggVorbis_File vorbis;
    if(ov_open_callbacks(fp, &vorbis, NULL, 0, OV_CALLBACKS_DEFAULT) != 0) {
        printf("music.ogg invalid.");
        return -1;
    }
    
    
    // Preload music
    printf("Preloading, please wait...\n");
    printf("This can take a while, especially on an old 3DS, sorry.\n");
    music_bin = (u8*)malloc((1 + MUSIC_SIZE)*sizeof(u8));
    vorbis_info* info = ov_info(&vorbis, -1);    
    // printf("Ogg file %d Hz, %d channels, %d kbit/s, total audio data %d bytes.\n", info->rate, info->channels, info->bitrate_nominal / 1024, MUSIC_SIZE);

    int readBytes = 0;
    while(readBytes < MUSIC_SIZE) {
        int section = 0;
        long bytes = ov_read(&vorbis, &music_bin[readBytes], MUSIC_SIZE, 0, 2, 1, &section);
        readBytes += bytes;
    }
    ov_clear(&vorbis);
    fclose(fp);

    waitForA("Loaded vorbis, press A -> B to continue");

    printf("Demobeginn imminent.\n");

    // Rocket startup
#ifndef SYNC_PLAYER
    printf("Now socketing...\n");
    SOC_buffer = (u32*)memalign(SOC_ALIGN, SOC_BUFFERSIZE);
    socInit(SOC_buffer, SOC_BUFFERSIZE);
    
    rocket = sync_create_device("sdmc:/sync");
#else
    rocket = sync_create_device("romfs:/sync");
#endif
    if(connect_rocket()) {
        return(0);
    }

    // Load shaders
    vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_size);
    shaderProgramInit(&shaderProgram);
    shaderProgramSetVsh(&shaderProgram, &vshader_dvlb->DVLE[0]);

    vshader_skybox_dvlb = DVLB_ParseFile((u32*)vshader_skybox_shbin, vshader_skybox_shbin_size);
    shaderProgramInit(&shaderProgramSkybox);
    shaderProgramSetVsh(&shaderProgramSkybox, &vshader_skybox_dvlb->DVLE[0]);

    vshader_bones_dvlb = DVLB_ParseFile((u32*)vshader_bones_shbin, vshader_bones_shbin_size);
    shaderProgramInit(&shaderProgramBones);
    shaderProgramSetVsh(&shaderProgramBones, &vshader_bones_dvlb->DVLE[0]);
    
    vshader_normalmapping_dvlb = DVLB_ParseFile((u32*)vshader_normalmapping_shbin, vshader_normalmapping_shbin_size);
    shaderProgramInit(&shaderProgramNormalMapping);
    shaderProgramSetVsh(&shaderProgramNormalMapping, &vshader_normalmapping_dvlb->DVLE[0]);
    
    // Sound on
    ndspInit();
    
    ndspSetOutputMode(NDSP_OUTPUT_STEREO);

    ndspChnSetInterp(0, NDSP_INTERP_LINEAR);
    ndspChnSetRate(0, SONG_SPS);
    ndspChnSetFormat(0, NDSP_FORMAT_STEREO_PCM16);
    
    float mix[12];
    memset(mix, 0, sizeof(mix));
    mix[0] = 1.0;
    mix[1] = 1.0;    
    ndspChnSetMix(0, mix);

    uint8_t *audio_buffer = (uint8_t*)linearAlloc(AUDIO_BUFSIZE * sizeof(int16_t) * 2);
    memset(wave_buffer,0,sizeof(wave_buffer));
    wave_buffer[0].data_vaddr = &audio_buffer[0];
    wave_buffer[0].nsamples = AUDIO_BUFSIZE / CHANNELS;
    wave_buffer[1].data_vaddr = &audio_buffer[AUDIO_BUFSIZE * sizeof(int16_t)];
    wave_buffer[1].nsamples = AUDIO_BUFSIZE / CHANNELS;
    
    // Init bitmap used for fading
    fadePixels = (Pixel*)linearAlloc(64 * 64 * sizeof(Pixel));
    InitialiseBitmap(&fadeBitmap, 64, 64, BytesPerRowForWidth(64), fadePixels);
    C3D_TexInit(&fade_tex, 64, 64, GPU_RGBA8);

    // Get first row value
    double row = 0.0;  

#ifndef SYNC_PLAYER
    if(sync_update(rocket, (int)floor(row), &rocket_callbakcks, (void *)0)) {
        printf("Lost connection, retrying.\n");
        if(connect_rocket()) {
            return(0);
        }
    }
#endif

    const struct sync_track* sync_fade = sync_get_track(rocket, "global.fade");
    const struct sync_track* sync_effect = sync_get_track(rocket, "global.effect");;    
    const struct sync_track* sync_img = sync_get_track(rocket, "global.image");
    
    // Start up first effect
    int current_effect = (int)sync_get_val(sync_effect, row + 0.01);
    effect_list[current_effect].init();

    // Play music
    ndspSetCallback(&audio_callback, 0);
    ndspChnWaveBufAdd(0, &wave_buffer[0]);
    ndspChnWaveBufAdd(0, &wave_buffer[1]);
    
    row = audio_get_row();

    int fc = 0;
    while (aptMainLoop()) {        
        if(!DUMPFRAMES) {
            row = audio_get_row();
        }
        else {
            printf("Frame dump %d\n", fc);
            row = ((double)fc * (32000.0 / 30.0)) / (double)SAMPLES_PER_ROW;
        }
        
#ifndef SYNC_PLAYER
        if(sync_update(rocket, (int)floor(row), &rocket_callbakcks, (void *)0)) {
            printf("Lost connection, retrying.\n");
            if(connect_rocket()) {
                return(0);
            }
        }
#endif

        // Effect switcher
        int new_effect = (int)sync_get_val(sync_effect, row);
        if(new_effect < 0) {
            new_effect = 0;
        }
        if(new_effect >= EFFECT_MAX) {
            new_effect = EFFECT_MAX - 1;
        }
        if(new_effect != -1 && new_effect != current_effect) {
            printf("effect switch %d -> %d\n", current_effect, new_effect);
            effect_list[current_effect].exit();
            current_effect = new_effect;
            effect_list[current_effect].init();
        }


        // Fading update
        fadeVal = sync_get_val(sync_fade, row);

        //printf("ppf\n");
        hidScanInput();
        
        // Respond to user input
        u32 kDown = hidKeysDown();
        if (kDown & KEY_START) {
            break; // break in order to return to hbmenu
        }  
        float slider = osGet3DSliderState();
        if(DUMPFRAMES_3D) {
            slider = DUMPFRAMES_3D_SEP;
        }

        float iod = slider / 3.0;

        // Draw
        effect_list[current_effect].render(targetLeft, targetRight, row, iod);

        // Frame dumper code
        if(DUMPFRAMES) {
            gspWaitForP3D();
            gspWaitForPPF();
            
            u8* fbl = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
            
            char fname[255];
            if(fc < 1000) {
                sprintf(fname, "3ds/dump1/fb_left_%08d.raw", fc);
            }
            else if(fc < 2000) {
                sprintf(fname, "3ds/dump2/fb_left_%08d.raw", fc);
            }
            else if(fc < 3000) {
                sprintf(fname, "3ds/dump3/fb_left_%08d.raw", fc);
            }
            else {
                sprintf(fname, "3ds/dump4/fb_left_%08d.raw", fc);
            }
            FILE* file = fopen(fname,"w");
            fwrite(fbl, sizeof(int32_t), SCREEN_HEIGHT * SCREEN_WIDTH, file);
            fflush(file);
            fclose(file);
            
            if(DUMPFRAMES_3D) {
                u8* fbr = gfxGetFramebuffer(GFX_TOP, GFX_RIGHT, NULL, NULL);
                if(fc < 1000) {
                    sprintf(fname, "3ds/dump1/fb_right_%08d.raw", fc);
                }
                else if(fc < 2000) {
                    sprintf(fname, "3ds/dump2/fb_right_%08d.raw", fc);
                }
                else if(fc < 3000) {
                    sprintf(fname, "3ds/dump3/fb_right_%08d.raw", fc);
                }
                else {
                    sprintf(fname, "3ds/dump4/fb_right_%08d.raw", fc);
                }
                file = fopen(fname,"w");
                fwrite(fbr, sizeof(int32_t), SCREEN_HEIGHT * SCREEN_WIDTH, file);
                fflush(file);
                fclose(file);
            }
        }

        fc++;
    }
    
    printf("Demo over, go home.\n");

    linearFree(fadePixels);
    
    // Sound off
    ndspExit();
    linearFree(audio_buffer);
    
    // Deinitialize graphics
    socExit();
    C3D_Fini();
    gfxExit();
    
    return 0;
}
